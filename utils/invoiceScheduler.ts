import { InvoiceSchedule, InvoiceScheduleFrequency, Lease, Invoice, TenantRenter, Property, Unit, PaymentCurrency } from '@/types';
import { generateInvoiceNumber, generateInvoiceData } from './invoiceGenerator';
import { DEFAULT_CURRENCY } from '@/constants/currencies';

export interface ScheduleCheckResult {
  shouldGenerate: boolean;
  nextGenerationDate: string;
  reason?: string;
}

export function calculateNextGenerationDate(
  schedule: InvoiceSchedule,
  fromDate: Date = new Date()
): string {
  const date = new Date(fromDate);
  const day = schedule.generation_day;
  
  date.setDate(day);
  
  if (date < new Date()) {
    switch (schedule.frequency) {
      case 'monthly':
        date.setMonth(date.getMonth() + 1);
        break;
      case 'quarterly':
        date.setMonth(date.getMonth() + 3);
        break;
      case 'semi-annual':
        date.setMonth(date.getMonth() + 6);
        break;
      case 'annual':
        date.setFullYear(date.getFullYear() + 1);
        break;
    }
  }
  
  return date.toISOString().split('T')[0];
}

export function shouldGenerateScheduledInvoice(
  schedule: InvoiceSchedule,
  existingInvoices: Invoice[]
): ScheduleCheckResult {
  const today = new Date();
  const nextGenDate = new Date(schedule.next_generation_date);
  
  if (schedule.status !== 'active') {
    return {
      shouldGenerate: false,
      nextGenerationDate: schedule.next_generation_date,
      reason: `Schedule is ${schedule.status}`,
    };
  }
  
  if (schedule.end_date) {
    const endDate = new Date(schedule.end_date);
    if (today > endDate) {
      return {
        shouldGenerate: false,
        nextGenerationDate: schedule.next_generation_date,
        reason: 'Schedule has ended',
      };
    }
  }
  
  if (today < nextGenDate) {
    return {
      shouldGenerate: false,
      nextGenerationDate: schedule.next_generation_date,
      reason: `Next generation scheduled for ${schedule.next_generation_date}`,
    };
  }
  
  const hasInvoiceForPeriod = existingInvoices.some((inv) => {
    const invDate = new Date(inv.invoice_date);
    const isFromSchedule = inv.auto_generated;
    const isForLease = inv.lease_id === schedule.lease_id;
    const isSameMonth = invDate.getMonth() === nextGenDate.getMonth();
    const isSameYear = invDate.getFullYear() === nextGenDate.getFullYear();
    
    return isFromSchedule && isForLease && isSameMonth && isSameYear;
  });
  
  if (hasInvoiceForPeriod) {
    const newNextDate = calculateNextGenerationDate(schedule, nextGenDate);
    return {
      shouldGenerate: false,
      nextGenerationDate: newNextDate,
      reason: 'Invoice already exists for this period',
    };
  }
  
  const newNextDate = calculateNextGenerationDate(schedule, nextGenDate);
  return {
    shouldGenerate: true,
    nextGenerationDate: newNextDate,
  };
}

export interface GenerateScheduledInvoiceParams {
  schedule: InvoiceSchedule;
  lease: Lease;
  tenantRenter: TenantRenter;
  property: Property;
  unit: Unit;
  existingInvoicesCount: number;
  currency?: PaymentCurrency;
}

export function generateScheduledInvoice(
  params: GenerateScheduledInvoiceParams
): Omit<Invoice, 'id' | 'tenant_id' | 'created_at' | 'updated_at'> {
  const {
    schedule,
    lease,
    tenantRenter,
    property,
    unit,
    existingInvoicesCount,
    currency = DEFAULT_CURRENCY,
  } = params;
  
  const invoiceDate = new Date().toISOString().split('T')[0];
  const dueDate = calculateDueDate(schedule);
  const invoiceNumber = generateInvoiceNumber(existingInvoicesCount);
  
  const rentPeriod = formatRentPeriodFromSchedule(schedule);
  
  const invoiceData = generateInvoiceData({
    lease,
    tenantRenter,
    property,
    unit,
    invoiceDate,
    dueDate,
    currency,
    invoiceNumber,
    includeLateFee: schedule.include_late_fee,
    lateFeeAmount: schedule.late_fee_amount || 0,
    autoGenerated: true,
    recurringPeriod: schedule.frequency,
    rentPeriod,
    notes: schedule.notes || `Auto-generated ${schedule.frequency} invoice`,
  });
  
  return invoiceData;
}

export function calculateDueDate(schedule: InvoiceSchedule): string {
  const today = new Date();
  const dueDate = new Date(today);
  dueDate.setDate(schedule.generation_day);
  
  if (dueDate < today) {
    dueDate.setMonth(dueDate.getMonth() + 1);
  }
  
  return dueDate.toISOString().split('T')[0];
}

export function formatRentPeriodFromSchedule(schedule: InvoiceSchedule): string {
  const date = new Date(schedule.next_generation_date);
  
  switch (schedule.frequency) {
    case 'monthly':
      return date.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
    case 'quarterly':
      const quarter = Math.floor(date.getMonth() / 3) + 1;
      return `Q${quarter} ${date.getFullYear()}`;
    case 'semi-annual':
      const half = date.getMonth() < 6 ? 1 : 2;
      return `H${half} ${date.getFullYear()}`;
    case 'annual':
      return `${date.getFullYear()}`;
    default:
      return date.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
  }
}

export function createInvoiceScheduleFromLease(
  lease: Lease,
  tenantId: string,
  options: {
    frequency?: InvoiceScheduleFrequency;
    autoSend?: boolean;
    includeLateFee?: boolean;
    lateFeeAmount?: number;
    startDate?: string;
    endDate?: string;
  } = {}
): Omit<InvoiceSchedule, 'id' | 'created_at' | 'updated_at'> {
  const frequency = options.frequency || 'monthly';
  const startDate = options.startDate || lease.start_date;
  const generationDay = lease.payment_due_day;
  
  const nextGenerationDate = calculateNextGenerationDate(
    {
      generation_day: generationDay,
      frequency,
    } as InvoiceSchedule,
    new Date(startDate)
  );
  
  return {
    tenant_id: tenantId,
    lease_id: lease.id,
    property_id: lease.property_id,
    unit_id: lease.unit_id,
    tenant_renter_id: lease.tenant_renter_id,
    frequency,
    start_date: startDate,
    end_date: options.endDate || lease.end_date,
    next_generation_date: nextGenerationDate,
    status: 'active',
    generation_day: generationDay,
    auto_send: options.autoSend ?? false,
    include_late_fee: options.includeLateFee ?? false,
    late_fee_amount: options.lateFeeAmount,
  };
}

export function getSchedulesReadyForGeneration(
  schedules: InvoiceSchedule[],
  invoices: Invoice[]
): InvoiceSchedule[] {
  return schedules.filter((schedule) => {
    const result = shouldGenerateScheduledInvoice(schedule, invoices);
    return result.shouldGenerate;
  });
}

export function getUpcomingScheduledInvoices(
  schedules: InvoiceSchedule[],
  daysAhead: number = 30
): (InvoiceSchedule & { daysUntil: number })[] {
  const today = new Date();
  const futureDate = new Date();
  futureDate.setDate(futureDate.getDate() + daysAhead);
  
  return schedules
    .filter((schedule) => schedule.status === 'active')
    .map((schedule) => {
      const nextGenDate = new Date(schedule.next_generation_date);
      const daysUntil = Math.ceil(
        (nextGenDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24)
      );
      
      return {
        ...schedule,
        daysUntil,
      };
    })
    .filter((schedule) => {
      const nextGenDate = new Date(schedule.next_generation_date);
      return nextGenDate >= today && nextGenDate <= futureDate;
    })
    .sort((a, b) => a.daysUntil - b.daysUntil);
}
